Include "MapBasic.def"

Declare Sub Main
declare sub increment(iProgress as integer,iProgressRange as integer,starttime as integer)

declare Function SplitStringAtCharacter(ByVal sInput As String, ByVal sSplitChar As String, sPartsArray() As String) As Integer

Dim iProgress,iProgressRange,starttime as integer

declare sub process()

Sub Main()
	'print Chr$(12) 'empty message
	'elect * from fä2 into ÄF
	'Open Table "C:\Users\crbk01\OneDrive - Region Gotland\Solen till vision\KomponentProgramm\ÄrendenMedIngenEllerFelFastighet.TAB" as ÄF
	Update HelaSolen Set ignorex = rowid DropIndex Auto
	Select fliken_Fastigheter "sökbegrepp",fliken_FastigheterFNR "fnr",ignorex "rowid" 
	from HelaSolen where fliken_Fastigheter <> "" AND fliken_FastigheterFNR = 0 into ÄF
	
	
	onError goto FSUrsprungsFastigheterMedSockenOc run command "Open Table ""C:\Users\crbk01\OneDrive - Region Gotland\To Vision, GDPR cleanup\MapInfoTables\skikt\Vanliga Tabfiler\UrsprungsFastigheterMedSockenOc.TAB"" as korrigerandeTabell" onError goto 0 'Open Table "G:\sbf\Livsmiljö\Gemensamt\mapbasic program projekt\skikt\Vanliga Tabfiler\FastigHeterMedSockenTraktSepGrouped.TAB" as korrigerandeTabell
		Select Socken from korrigerandeTabell where socken <> "" group by socken into socken
	
	select * from ÄF group by sökbegrepp into Left

	fetch first from Left
	startTime = timer()
	iprogressRange = tableInfo(left,tab_info_nRows)
	iprogress = 0	
	ProgressBar "Processing...." & iProgressRange & " items"
		     Calling process
	Range iProgressRange

	commit table helaSolen
	Select fliken_Fastigheter "sökbegrepp",fliken_FastigheterFNR "fnr",ignorex "rowid" from HelaSolen where fliken_Fastigheter <> "" AND fliken_FastigheterFNR = 0 into left

	end program
FSUrsprungsFastigheterMedSockenOc:
	print error$() end program
End Sub


'FNR, BETECKNING, UFNR, UBETECKNING, 
'left$(UBETECKNING,instr(1,UBETECKNING," ")) "USocken",
'LTrim$(Mid$(UBETECKNING,instr(1,UBETECKNING," "),(len(UBETECKNING)-instr(1,UBETECKNING," ")-(len(UBETECKNING)-instr(1,UBETECKNING,":")+2)))) "UTrakt",
'right$(UBETECKNING,(len(UBETECKNING)-instr(1,UBETECKNING,":")+2)) "UblockEnhet"

'for each row in FelFastighet
'
'see if any socken match 
'
'if socken match
'	and sökbegräp <> socken
'		see if Track is in sökbegräpp
'			if true
'				see if blockenhet
'					if true
'						update fnr
'						print updated
'end if
'
'increment()
sub process()

	fetch first from socken

	do until eot(socken)
		dim sokStreng,sockenB,FsTrakt,blockb as string B		sockenB = socken.col1 sökb = Left.sökbegrepp
		
		if instr(1,sokStreng,left$(sockenB,5)) <> 0 then
			if sokStreng <> sockenB then select trakt from korrigerandeTabell where socken = SockenB AND trakt <> "" group by trakt into trakt fetch first from trakt
				do until eot(Trakt)
					korrigerandeTrackt = trakt.Col1
					dim sPartsArray() As String
					
					if(SplitStringAtCharacter(korrigerandeTrackt, " ", sPartsArray) = 2) then
						korrigerandeTrackt = spartsArray(2)
					else
						korrigerandeTrackt = korrigerandeTrackt
					end if
					
					if instr(1,sokStreng,korrigerandeTrackt) <> 0 then	
B						if sökb <> Socken & " " & fstrakt then
							select blockenhet from korrigerandeTabell where socken = SockenB AND trakt = fstrakt AND blockenhet <> ""  group by blockenhet into blockenhet
							fetch first from blockenhet
							
							do until eot(blockenhet)
							blockB = Blockenhet.col1
								if instr(1,sokStreng,blockB) <> 0 then
B									dim FnrF,idx as integer
									
									select fnr from fs where socken = SockenB AND trakt = fstrakt AND blockenhet = blockB group by fnr into ressult
									fetch first from ressult
									FnrF = ressult.fnr
									idx = Left.sökbegrepp
									
									update ÄF set fnr=FnrF where sökbegrepp = idx
									print "updated"
									goto loopend
								end if
								fetch next from blockenhet
							loop	
						else
							goto LoopEnd
						end if
						'nödvändigt för att kunna kolla både lilla och stora bjärs, tex
					end if
					fetch next from trakt
				loop
			else
				goto LoopEnd
			end if
		end if		
			
		
		fetch next from socken
	loop
	
	LoopEnd:
	fetch Next from Left
	call increment(iProgress,iProgressRange,starttime)		
end sub

sub increment(iProgress as integer,iProgressRange as integer,starttime as integer)

	iProgress = iProgress + 1 
	If iProgress <= iProgressRange Then
		if iProgress mod 100 = 0 then 'at each hundred incrementetations, short time summery is printed
			dim	totaltidH,totaltidM,totaltids,upskattad,upskattadH,upskattadM,upskattads as integer
			,tidperEnhet,totaltid as float
			
			totaltid = timer() - starttime	
			tidperEnhet = totaltid/iprogress		
			
			if(totaltid > 3600) then
				totaltidH = totaltid/3600
				totaltidM = (totaltid mod 3600) / 60
				totaltids = (totaltid mod 3600) mod 60
			else
				totaltidH = 0
				if(totaltid > 60) then
					totaltidM = totaltid / 60
					totaltids = totaltid mod 60
				else
					totaltidM = 0
					totaltids = totaltid
				end if
			end if
			
			
			OnError goto OverflowError
				upskattad = iProgressRange * tidPerEnhet
			onError goto 0
			if false then 
				overflowError:
				upskattad = iProgressRange
			End If
			
			upskattadH = upskattad/3600
			upskattadM = (upskattad mod 3600) / 60
			upskattads = (upskattad mod 3600) mod 60
			
			
			print iProgress & "upskattat: " & upskattadH & "h" & upskattadM & "m" & upskattads & "s totalt:" & totaltidH & "h" & totaltidM & "m" & totaltids & "s passerade"
		End If
		
		ProgressBar = iProgress
	Else
		ProgressBar = -1
	End If

end sub

Function SplitStringAtCharacter(ByVal sInput As String, ByVal sSplitChar As String, sPartsArray() As String) As Integer
'http://twiav-tt.blogspot.se/2013/05/mapbasic-bespoke-function-to-split.html*********************************************************************************************
	OnError Goto HandleError
	
	Dim iPos, iEnd, iCount As Integer
	
	If Len(sInput) = 0 Then
		SplitStringAtCharacter = 0
		Exit Function
	End If
	    
	Do While iEnd <= Len(sInput)
		iPos = iEnd + 1
		iEnd = InStr(iPos, sInput, sSplitChar)
		If iEnd = 0 Then
			iEnd = Len(sInput) + 1
		End If
	
		iCount = iCount + 1
		ReDim sPartsArray(iCount)
		sPartsArray(iCount) = Mid$(sInput, iPos, iEnd - iPos)
	Loop
	
	SplitStringAtCharacter = UBound(sPartsArray)
	
	Exit Function
	'---------------------------
	HandleError:
	Note Error$()

End Function
